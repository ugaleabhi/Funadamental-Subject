ðŸ”¹ Core OOPs Concepts
1. Class & Object

Q: What is a class and object in C++?

A: A class is a user-defined blueprint. An object is an instance of a class created at runtime.

2. Encapsulation

Q: What is encapsulation?

A: Wrapping data (variables) and methods into a single unit (class). Achieved using access specifiers (private, protected, public). Improves security and modularity.

3. Abstraction

Q: What is abstraction in C++?

A: Hiding implementation details and showing only the functionality. Achieved using abstract classes (pure virtual functions) and interfaces.

4. Inheritance

Q: Types of inheritance in C++?

A: Single, Multiple, Multilevel, Hierarchical, Hybrid.

Q: Why inheritance?

A: Code reusability, method overriding, polymorphism.

5. Polymorphism

Q: What is polymorphism?

A: One name, many forms.

Compile-time (static): Function overloading, Operator overloading.

Runtime (dynamic): Function overriding with virtual functions.

6. Virtual Functions & V-Table

Q: What are virtual functions?

A: Functions in base class marked with virtual, allow runtime overriding in derived class.

Q: What is vtable?

A: A table of function pointers maintained per class to support runtime polymorphism.

7. Constructor & Destructor

Q: Types of constructors?

A: Default, Parameterized, Copy constructor.

Q: Why destructor is virtual?

A: To ensure proper cleanup in case of inheritance.

8. Friend Function

Q: What is a friend function?

A: A function declared with friend keyword, can access private/protected members of a class.

9. Operator Overloading

Q: Can we overload all operators?

A: Most can, but not all (e.g., ::, .*, sizeof, ?:).

Example: Complex operator+(Complex obj);

10. This Pointer

Q: What is this pointer?

A: A pointer that points to the current object of the class. Automatically passed to non-static member functions.

11. Static Members

Q: What are static variables and functions in a class?

A: Shared across all objects. Functions can access only static members.

12. Overloading vs Overriding

Q: Difference?

A:

Overloading: Same function name, different parameters, compile-time polymorphism.

Overriding: Derived class redefines base class function, runtime polymorphism.

13. Shallow Copy vs Deep Copy

Q: Difference?

A:

Shallow Copy: Copies pointer values, not actual data.

Deep Copy: Copies actual data along with dynamically allocated memory.

14. Pure Virtual Function & Abstract Class

Q: What is pure virtual function?

A: virtual void fun() = 0; â†’ No implementation in base class.

Q: Abstract class?

A: A class with at least one pure virtual function.

15. Multiple Inheritance & Diamond Problem

Q: What is diamond problem?

A: Ambiguity due to multiple inheritance. Solved by using virtual base classes.



ðŸ”¹ OOPS Quick Recall for Interviews (C++)

Class & Object â€“ Class = blueprint, Object = instance. Encapsulates data + methods.

Encapsulation â€“ Wrapping data & functions in a single unit (class). Provides data hiding.

Abstraction â€“ Hiding implementation details, showing only necessary features. Achieved via abstract classes & interfaces.

Inheritance â€“ Reuse existing class properties. Types: Single, Multiple, Multilevel, Hierarchical, Hybrid.

Polymorphism â€“ One entity, many forms.

Compile-time (Function/Operator Overloading).

Runtime (Virtual Functions, Method Overriding).

Constructor & Destructor â€“ Constructor = initializes object, Destructor = cleans memory.

Types of Constructors â€“ Default, Parameterized, Copy constructor.

Virtual Functions â€“ Enables runtime polymorphism, achieved via vtable.

Pure Virtual Function & Abstract Class â€“ Function with =0; Abstract class cannot be instantiated.

Friend Function â€“ Non-member function, but can access private/protected data.

Static Members â€“ Belong to class, not object. Shared by all objects.

this Pointer â€“ Points to the current object.

Operator Overloading â€“ Redefine operator behavior for user-defined types.

Function Overloading vs Overriding â€“ Overloading = same name, different parameters; Overriding = same function, different class.

Virtual Destructor â€“ Ensures proper cleanup in inheritance hierarchy.

Shallow Copy vs Deep Copy â€“ Shallow: copies reference; Deep: copies actual content.

Object Slicing â€“ Assigning derived object to base object loses derived part.

Interface in C++ â€“ Achieved via abstract class with only pure virtual functions.

Dynamic Binding vs Static Binding â€“ Static: compile time, Dynamic: runtime (via virtual).

Access Specifiers â€“ Public, Private, Protected. Control visibility & inheritance type.

Diamond Problem â€“ Ambiguity in multiple inheritance. Solved using virtual inheritance.

Overloading Restrictions â€“ Cannot overload ::, .*, sizeof, ?:, typeid.

Inline Functions â€“ Compiler replaces call with function body; reduces overhead.

Templates â€“ Generic programming. Types: Function template, Class template.

Exception Handling â€“ try, catch, throw. Prevents abnormal termination.







1. Class & Object

Blueprint of data + functions.

class Car {
public:
    string brand;
    void drive() { cout << "Driving " << brand; }
};
int main() {
    Car c; c.brand="BMW"; c.drive();
}


2. Encapsulation

Wrapping data & methods, data hiding using private.

class Student {
private: int marks;
public: 
    void setMarks(int m){ marks=m; }
    int getMarks(){ return marks; }
};


3. Abstraction

Hiding implementation, showing only essentials (using abstract class/pure virtual).

class Shape {
public: virtual void draw() = 0; // pure virtual
};
class Circle: public Shape {
public: void draw(){ cout<<"Circle"; }
};


5. Polymorphism

Compile-time (function/ operator overloading)

class Math {
public: 
    int add(int a,int b){ return a+b; }
    double add(double a,double b){ return a+b; }
};

6. Constructor & Destructor

Special functions for init & cleanup.

class A {
public:
    A(){ cout<<"Constructor"; }
    ~A(){ cout<<"Destructor"; }
};


7. Copy Constructor

Initializes object with another object.

class Test {
    int x;
public:
    Test(int a){ x=a; }
    Test(const Test &t){ x=t.x; }  // Copy constructor
};



8. Friend Function

Access private/protected of a class.

class Box {
private: int width;
public: Box(){ width=10; }
    friend void print(Box);
};
void print(Box b){ cout<<b.width; }



9. Operator Overloading

Customize operator behavior.

class Complex {
    int r,i;
public:
    Complex(int a,int b){ r=a; i=b; }
    Complex operator+(Complex c){ return Complex(r+c.r, i+c.i); }
};


11. Virtual Functions & V-Table

Enable runtime polymorphism.

class Base { public: virtual void show(){ cout<<"Base"; }};
class Derived: public Base { public: void show(){ cout<<"Derived"; }};


12. Pure Virtual Function & Abstract Class

Used for abstraction.

class Shape {
public: virtual void draw()=0;  // abstract
};

13. Static Members

Belong to class not object.

class Demo {
public:
    static int count;
};
int Demo::count=0;


14. â€˜thisâ€™ Pointer

Refers to current object.

class A {
    int x;
public:
    void setX(int x){ this->x = x; }
};
15. Memory Management (new/delete)
int* p = new int(10);
delete p;
